load imp-semantics
load imp#-syntax
load imp#-strictness


--- The computation configuration item for IMP#.
fmod IMP#-K-CONFIG is
  protecting IMP#-PROGRAM .
  including IMP-K-CONFIG .

  --- programs are also K labels
  subsort Program < KLabel .

  --- ;; is an operation on ~>
  eq k(D:Decl ;; FD:FuncDecl) = k({D:Decl} ~> FD:FuncDecl) .

  --- 내가 만듬 : Parameter Binding Operator
  --- | VarList | ValueList | 형태의 KLabel 정의
  op | _ | _ | : VarIdList ValueList -> KLabel [ctor] .
endfm


--- Call stacks for IMP#
fmod CALL-STACK is
  protecting MAP{VarId,Nat} * (op _,_ to _;_) .
  including K-COMPUTATION .

  --- each stack item is a triple of a local env, a computation, and 
  --- a memory location.
  sort StackItem .
  op item : Map{VarId,Nat} K Nat -> StackItem [ctor] .

  sort CallStack .
  op nilStack : -> CallStack [ctor] .        --- the empty stack
  op _::_ : StackItem CallStack -> CallStack [ctor] .
endfm


--- K configurations for IMP#. 
fmod IMP#-CONFIG is
  protecting MAP{Nat,Value} * (op _,_ to _;_) .
  including IMP#-K-CONFIG .
  including CALL-STACK .

  op env : Map{VarId,Nat} -> KConfigItem [ctor] .   --- local env
  op stack : CallStack -> KConfigItem [ctor] .      --- call stack
  op genv : Map{VarId,Nat} -> KConfigItem [ctor] .  --- global env
  op store : Map{Nat,Value} -> KConfigItem [ctor] . --- memory
  op in : ValueList -> KConfigItem [ctor] .         --- input stream
  op out : ValueList -> KConfigItem [ctor] .        --- output stream
  op functions : FuncDecl -> KConfigItem [ctor] .   --- function decls
  op nextLoc : Nat -> KConfigItem [ctor] .          --- next store location
endfm


--- K rules for IMP#. This shares the basic rules (in IMP-RULES-BASIC)
--- with IMP, but the other rules are different.
mod IMP#-RULES is
  including IMP-RULES-BASIC .
  including IMP#-CONFIG .
  including IMP#-STRICTNESS .

  var K K' : K .           
  var X F : VarId .
  var V V' : Value .   
  var ENV ENV' GENV : Map{VarId,Nat} .
  var MEM : Map{Nat,Value} .
  var L L' N : Nat .
  var FD : FuncDecl .
  var I : Int .
  vars S S' S1 S2 : Stmt .
  var VL VL' : ValueList .
  vars EL EL' : ExpList .
  vars XL XL' : VarIdList .
  var E : Exp .
  var STACK : CallStack .
  var BLOCK : Block .

  --- variable lookup
  rl k(X ~> K) env((X |-> L) ; ENV) store((L |-> V) ; MEM)
  => k(V ~> K) env((X |-> L) ; ENV) store((L |-> V) ; MEM) .

---TODO: Define the remaining rewrite rules for the K semantics of IMP#. 
---      You may define some auxiliary operations and equations, if necessary.
--- TODO: IMP#의 K 의미론에 대한 나머지 재작성 규칙(rewrite rules)을 정의하라.
---       필요하다면 보조 연산(auxiliary operations)과 방정식(equations)을 추가로 정의해도 된다.

  rl k({var X} ~> K) env(ENV) nextLoc(L)
  => k(K) env((X |-> L) ; ENV) nextLoc(L + 1) .

  rl k(X := V ~> K) env((X |-> L) ; ENV) store(MEM)
  => k(K) env((X |-> L) ; ENV) store(insert(L, V, MEM)) . --- store((L |-> V) ; MEM) .

  rl k(++ X ~> K) env((X |-> L) ; ENV) store((L |-> # I) ; MEM)
  => k(# (I + 1) ~> K) env((X |-> L) ; ENV) store(insert(L, # (I + 1), MEM)) . --- store((L |-> # (I + 1)) ; MEM) . 

  rl k(while E do S end ~> K) 
  => k(if E then (S ; while E do S end) else skip fi ~> K) .

  rl k(if # true then S1 else S2 fi ~> K) 
  => k(S1 ~> K) .

  rl k(if # false then S1 else S2 fi ~> K) 
  => k(S2 ~> K) .

  rl k(read ~> K) in(V, VL)
  => k(V ~> K) in(VL) .

  rl k(print(V) ~> K) out(VL)
  => k(K) out(VL, V) .

  rl k(halt ~> K) 
  => k(.K) .

  rl k(@ X[# I] ~> K) env((X |-> L) ; ENV) store(((L + I) |-> V) ; MEM)
  => k(V ~> K) env((X |-> L) ; ENV) store(((L + I) |-> V) ; MEM) .

  rl k({var X[# I]} ~> K) env(ENV) nextLoc(L)
  => k(K) env((X |-> L) ; ENV) nextLoc(L + I) .

  rl k(@ X[# I] := V ~> K) env((X |-> L) ; ENV) store(MEM)
  => k(K) env((X |-> L) ; ENV) store(insert(L + I, V, MEM)) . --- store(((L + I) |-> V) ; MEM) .

  rl k(@ F(VL) ~> K) env(ENV) genv(GENV) stack(STACK) functions(function F(XL) {BLOCK} FD) nextLoc(L)
  => k(| XL | VL | ~> BLOCK) env(GENV) genv(GENV) stack(item(ENV, K, L) :: STACK) functions(function F(XL) {BLOCK} FD) nextLoc(L) .
  
  rl k(| X, XL | V, VL | ~> K)
  => k({var X} ~> X := V ~> | XL | VL | ~> K) .

  rl k(| nil | nil | ~> K) 
  => k(K) .

  rl k(return V ~> K) env(ENV) stack(item(ENV', K', L') :: STACK) nextLoc(L')
  => k(V ~> K') env(ENV') stack(STACK) nextLoc(L') .

  rl k(call V ~> K) 
  => k(K) .

  rl k(FD) env(ENV) genv(empty) functions(empty)
  => k(call @ 'main()) env(ENV) genv(ENV) functions(FD) .
endm

rew k({var X}) env(empty) nextLoc(0) .

load imp#-examples.maude

mod IMP-TEST is
  protecting IMP#-EXAMPLE-CODE .
  including IMP#-RULES .

  var P : Program .
  var VL : ValueList .
  var CF : KConfig .

  --- returns an initial configuration for program P and input stream VL.
  op init : Program ValueList -> KConfig .
  eq init(P, VL) 
   = k(P) env(empty) stack(nilStack) genv(empty) store(empty) 
     in(VL) out(nil) functions(empty) nextLoc(0) .

  --- returns the output stream, when there is no more computation in k. 
  op getOutput : KConfig -> ValueList .
  eq getOutput(k(.K) out(VL) CF) = VL .
endm

rew k('x) env('x |-> 0) stack(nilStack) genv(empty) store(0 |-> # true)
  in(VL) out(nil) functions(empty) nextLoc(0) .


rew init(function 'main() {p1}, nil) .
rew init(function 'main() {p2}, nil) .
rew init(function 'main() {p3}, nil) .
rew init(function 'main() {p4}, nil) .
rew init(function 'main() {p5}, nil) .
rew init(function 'main() {p6}, nil) .

rew getOutput(init(p3+, # 5)) .
rew getOutput(init(p4+, # 100)) .
rew getOutput(init(p6+, # 100)) .
rew getOutput(init(p7+, nil)) .
rew getOutput(init(p8+, # 20)) .
rew getOutput(init(p9+, (# 12, # 2, # 4, # 6, # 8, # 1, # 3, # 5, # 7, # 4, # 3, # 2, # 1))) .
rew getOutput(init(p10+, (# 10, # 2, # 3, # 5, # 7, # 11, # 13, # 17, # 19, # 23, # 29, # 17))) .

